# Studio1 JSONtoREACT Documentation & Roadmap

## Project Overview

**Studio1** is a visual design builder application where users create web designs using the ONE system.
- **UI Theme (ui-theme.json)** - Powers Studio1's interface (dogfooding), exports to React
- **ONE Theme (one-theme.json)** - User's design output, exports to HTML/other formats

## System Architecture

### Core Element System
All elements in Studio1 are type "one" - a single, unified element type with behaviors controlled through presets.

#### Base Architecture
- **`.ui`** - Theme wrapper providing CSS variable scope for Studio interface
- **`.one`** - Base element class with minimal styling (position: relative, display: block)
- **Presets** - Composable style packages that add functionality

#### CSS Architecture
```css
/* Global Reset (global.css) */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Generated by Theme Processor */
.ui { /* all CSS variables */ }
.one { /* position: relative; display: block; */ }
.box { /* grid system */ }
.primary { /* color scheme */ }
```

#### HTML Output Structure
- **UI Theme**: `<div class="ui"><div class="one box primary">Content</div></div>`
- **ONE Theme**: `<div class="one box primary">Content</div>` (clean export)

### Preset System
Three categories of composable presets:

1. **Layouts** - Structure, grids, sizing
   - `containers/box` - Grid container system (now hydration-aware)
   - `sizing/full-height` - Height presets
   - `grids/grid-bento-5` - 5-area dashboard layout with auto-grid-areas
   - `grids/grid-cols-aligned` - 3-column grid with child alignment hydration and auto-grid-areas
   - `grids/grid-cols` - Auto-column layout based on number of children with auto-grid-areas
   - `grids/grid-rows` - Vertical stack layout with auto-grid-areas

2. **Components** - Atomic UI elements
   - `button` - Button behaviors
   - `field` - Input field styles
   - `checkbox`, `slider` - Form elements

3. **Looks** - Visual styling and theming
   - `primary`, `secondary` - Color schemes

## Current Status


### Complete Element Example
```json
"box1": {
  "type": "one",
  "id": "box-001",
  "data-label": "layer-tree",
  "layouts": "box" "full-height",
  "components": "button",
  "looks": "primary",
  "grid-area": "a",
  "grid": {
    "areas": "'a' 'b' 'c'",
    "cols": "1fr",
    "rows": "40px 1fr 40px"
  },
  "inline-styles": { *minimal almost never use this use presets instead*
    "padding": "1rem",
    "overflow": "auto"
  },
  "content": "Click Me",
  "children": ["child1", "child2"],
  "onClick": "toggle-panel"
}
```

### CSS Class Output
- UI Theme: `class="ui one box full-height button primary rounded"` (scoped to .ui)
- ONE Theme: `class="one box full-height button primary rounded"` (no .ui scope)

### Property Definitions

#### Core Properties
- **type**: Always "one" - defines the element type
- **data-label**: User reference label (not for HTML, just for identification in editor)
- **content**: Text content to display
- **children**: Array of child element IDs (for flat structure) or nested elements *what does this mean aray for childern en nested element, do we still neeed to define children or is it optional in nexted?*

#### Styling Properties (Three Categories + General)
- **layouts**: Array of layout presets (from layouts category)
  - Examples: `["box"]`, `["box", "bento-5"]`, `["box", "full-height"]`
  - Controls: structure, grid systems, sizing
- **components**: Array of component presets (from components category)
  - Examples: `["button"]`, `["field"]`, `["checkbox"]`, `["slider"]`
  - Controls: atomic UI element behaviors and styles
- **looks**: Array of visual presets (from looks category)
  - Examples: `["primary"]`, `["secondary", "bold-text-block"]`
  - Controls: colors, borders, shadows, visual effects, theming
- **presets**: General presets array (all)
  - Examples: `["custom-class"]`, `["box", "primary", "special"]`
  - Flexible preset application
- **grid-area**: Positions element in parent's grid always use universal grid areas ( "a", "b", "c") never use semantic names liek header etc. 

#### Inline Configuration
- **grid**: Direct grid configuration (overrides preset grids)
  ```json
  "grid": {
    "areas": "'a b c'",
    "cols": "1fr 2fr 1fr", 
    "rows": "auto"
  }
  ```
  Produces inline styles: `style="--grid-template-areas: 'a b c'; --grid-template-columns: 1fr 2fr 1fr';"`

- **inline-styles**: Direct CSS variable overrides *these are still being tested for their value ion ur system we wont know the full value until we get the dashbard ui interface running*
  ```json
  "inline-styles": {
    "padding": "2rem",
    "overflow": "hidden",
    "font-size": "1.125rem"
  }
  ```
  - Automatically adds `--` prefix to match your CSS variables
  - Use exact CSS variable names (no mapping)
  - Produces: `style="--padding: 2rem; --overflow: hidden; --font-size: 1.125rem;"`

#### Interaction
- **onClick**: Action identifier for click events

### Why Arrays for Presets?
1. **Clarity**: `["box", "primary"]` is clearer than `"box primary"`
2. **Manipulation**: Easier to add/remove presets programmatically
3. **Validation**: Can validate each preset exists
4. **Merging**: Simple to combine preset arrays from different sources

### Style Priority Order
1. Base `.one` styles (minimal: position, display, box-sizing)
2. Layout presets (e.g., `box` adds grid system)
3. Component presets (e.g., `button` adds button styles)
4. Inline grid configuration (if provided)
5. Look presets (e.g., `primary` adds colors)
6. Inline-styles (final overrides - always win)



### Important Principles
- NO themes (no traditional sm md ld primary-surface primary-content etc.)
- Everything is ONE element with presets
- Direct CSS values only - from the base variabls 
- Grid areas for all positioning
- Flat structure for visual editing
- Inline-styles for final CSS variable overrides *testing*

## Theme Processor System (AS-BUILT)

### How It Works
1. **Loads JSON theme** ‚Üí Generates CSS ‚Üí Injects into page
2. **Variable Scoping**: All variables scoped to `.ui` class for UI theme
3. **Preset Discovery**: Automatically finds presets in subcategories
4. **Double-Set Pattern**: Sets both CSS variable AND applies it
   ```css
   .primary {
     --background-color: red;
     background-color: var(--background-color);
   }
   ```

### Import System
Themes can import other JSON files:
```json
{
  "imports": ["./base-variables.json"],
  "presets": { /* custom presets */ }
}
```

### Debug Mode
- Currently available via `<JSONtoREACT debug={true} />`
- Shows structure processing and ID mappings in console
- Useful for development, should be off in production

## Runtime Theme Processor (COMPLETE SYSTEM)

### Core Functionality
The Runtime Theme Processor converts JSON theme configurations into CSS at runtime:
1. **Input**: JSON theme file with variables, presets, and structure
2. **Processing**: Generates CSS classes and variables
3. **Output**: Injects `<style>` tag into page head

### Theme Structure
```json
{
  "version": "1.0.0",
  "name": "Theme Name",
  "class": "ui",  // For UI theme only
  "imports": ["./base-variables.json"],  // Optional imports
  "variables": {
    // 100+ CSS variables with defaultValue, type, category
  },
  "oneElement": {
    "one": {
      "position": "relative",
      "display": "block"
    }
  },
  "presets": {
    "layouts": { /* box, dashboard-5, positions */ },
    "components": { /* button, field, checkbox */ },
    "looks": { /* primary, secondary, neutral */ }
  },
  "structure": {
    // Flat structure with ID references
  }
}
```

### Variable System (NOT STYLES, NO ADDING OR EDITING THESE)
- **100+ CSS Variables**: Colors, sizing, layout, typography, etc.
- **Default Values**: Every variable has a default 
- **Categories**: Organized by purpose (colors, sizing, spacing, etc.)
- **Scoping**: Variables cascade through child elements

### Preset System Features
1. **Auto-Discovery**: Finds presets in any level of nesting
2. **Double-Set Pattern**: 
   ```css
   .primary {
     --background-color: red;        /* Sets variable */
     background-color: var(--background-color);  /* Applies it */
   }
   ```
3. **Subcategory Support**: `presets.layouts.positions.a` ‚Üí `.a`

### UI Theme vs ONE Theme

#### UI Theme (Studio Interface)
- **Scope**: `.ui` class wraps everything
- **Purpose**: Powers Studio1 editor interface
- **Structure**: Dashboard components, toolbars, panels
- **Output**: `<div class="ui"><div class="one box">...</div></div>`

#### ONE Theme (User Designs)
- **Scope**: No `.ui` wrapper - clean output
- **Purpose**: User-created designs for export
- **Structure**: Whatever the user builds
- **Output**: `<div class="one box">...</div>`
- **Export Ready**: Clean HTML without framework dependencies

### Integration with JSONtoREACT
1. Theme processor generates all CSS classes and variables
2. JSONtoREACT reads structure and applies classes
3. Inline-styles in elements reference same CSS variables
4. Everything stays synchronized

### Development vs Production
- **Development Mode**: All variables output for DevTools access
- **Production Mode**: Tree-shaking - only used variables output
- **Console Messages**: 
  - `üé® Loading ui theme`
  - `üìù Generated CSS length: XXXX`
  - `üíâ Injected CSS`

## Content Type Architecture (CRITICAL - Next Implementation)

### The Problem We're Solving
HTML elements can't contain both text and an image directly - they need structure. Traditional approaches use background images or complex nesting. Our solution keeps everything as content while maintaining visual editing simplicity.

### Single Element, Multiple Content Types
Every element is type "one" with a contentType property:
- `contentType: "text"` - Text content only
- `contentType: "media"` - Image/video content only  
- `contentType: "none"` - Container only (default)

### Auto-Split Pattern
When user adds BOTH text + media to a single element:
1. System automatically creates two child elements
2. Original becomes a group container
3. Children get appropriate contentType

#### Before Auto-Split:
```json
{
  "type": "one",
  "contentType": "text",
  "content": "Hello World"
}
```

#### After User Adds Image:
```json
{
  "type": "one",
  "contentType": "none",
  "presets": ["box", "group"],
  "children": ["text-001", "media-001"]
}
```

With flat structure:
```json
{
  "text-001": {
    "type": "one",
    "contentType": "text",
    "content": "Hello World",
    "presets": ["text"]
  },
  "media-001": {
    "type": "one", 
    "contentType": "media",
    "src": "image.jpg",
    "presets": ["media"]
  }
}
```

### Why This Matters
1. **No Background Images** - Everything is real content, stackable, reorderable
2. **Visual Flexibility** - Layer multiple images, adjust opacity per layer
3. **Clean HTML Export** - Proper semantic structure, not divs with backgrounds
4. **R2 Storage Simplified** - All images are content, not CSS references
5. **Intuitive Editing** - What you see is the actual structure

## Flat Structure for Visual Editing (CORE CONCEPT)

### Visual Builder Workflow
1. **Design Mode (Flat)**
   - All elements at root level
   - Referenced by IDs in children arrays
   - Visual drag/drop/resize
   - No deep nesting

2. **Convert to Grid**
   - Analyze positions
   - Generate grid template
   - Assign grid areas
   - Maintain visual layout

3. **Export Mode (Nested)**
   - Proper semantic nesting
   - SEO-ready HTML
   - Maintains design intent

## Development Roadmap

### Phase 1: Hydration System Expansion
- [ ] Named-based hydration (scope: "start", "center", "end")
- [ ] Grid-area-based hydration (`_area-styles`)
- [ ] Property injection hydration (`_hydrate-children`)
- [ ] Nested hydration patterns
- [ ] Hydration override system documentation

### Phase 1.5: Grid Area Assignment Flexibility
- [ ] Implement toggle/configuration for grid area assignment modes
- [ ] Option 1: Universal assignment (current) - all elements get areas
- [ ] Option 2: Parent-controlled - only when parent enables it
- [ ] Option 3: Element-level opt-out with `_no-auto-grid-area` property
- [ ] Consider global configuration in theme.json
- [ ] Documentation for when to use each mode
- [ ] Potential preset property: `_grid-area-mode: "universal" | "parent" | "none"`

### Phase 2: Content Type System
- [ ] Implement contentType property (text/media/none)
- [ ] Create auto-split functionality for mixed content
- [ ] Build group/ungroup functionality
- [ ] Add flatten/unflatten for editing

### Phase 3: Component Library (IN PROGRESS)
- [x] Create shadcn-inspired component presets
  - [x] Button with exact shadcn styling
  - [x] Switch with CSS pseudo-element thumb
  - [ ] Input/Field component
  - [ ] Checkbox component
  - [ ] Select dropdown
  - [ ] Slider component
- [ ] Build component documentation
- [ ] Create component preview system

#### Components in Testing:
**Button**: Full shadcn styling applied directly (may separate into variants later)
**Switch**: Using CSS `::before` for thumb (testing vs separate component approach)

### Phase 3: Visual Editor
- [ ] Complete LayerTree component
- [ ] Integrate DirectRenderer with JSONtoREACT
- [ ] Build property panels for each content type
- [ ] Implement drag-and-drop functionality

### Phase 4: Export System
- [ ] ONE theme generation from UI designs
- [ ] Clean HTML export without framework
- [ ] Component library export
- [ ] Design system documentation export

## Technical Implementation Notes

### File Structure
- `/src/components/JSONtoREACT.tsx` - Core React generator
- `/src/utils/autoIdHelper.ts` - Auto-ID generation (currently generates one-XXX)
- `/src/theme/runtimeThemeProcessor.ts` - JSON to CSS conversion
- `/public/data/themes/ui-theme.json` - Studio interface theme
- `/public/data/themes/one-theme.json` - User design theme (future)

## Features in Testing/Transition

### Grid Area Assignment System (IN TRANSITION)
Currently using universal assignment for simplicity.

#### Current Implementation (Active):
- **Universal**: All elements with type 'one' automatically receive grid areas based on index
- Simple and predictable: first child gets 'a', second gets 'b', etc.
- No configuration required - works everywhere automatically
- Code: `if (element.type && element.type === 'one' && index >= 0)`

#### Alternative Implementation (Removed but documented):
- **Parent-controlled**: Grid presets with `"_auto-grid-areas": true` enable assignment
- More explicit control for complex layouts
- Functions removed for clean codebase but preserved here

#### Testing Notes:
- Universal approach chosen for current phase due to simplicity
- Parent-controlled implementation removed but fully documented below
- May implement toggle between both systems in future

#### How to Restore Parent-Controlled Grid Areas:

1. **Change the grid area assignment logic in JSONtoREACT.tsx** around line 152:
```javascript
// Change from:
} else if (element.type && element.type === 'one' && index >= 0) {

// To:
} else if (parentElement && shouldAutoAssignGridArea(parentElement, config)) {
```

2. **Add these functions before the closing brace of JSONtoREACT component**:

```typescript
/**
 * Check if a parent element has auto-grid-areas enabled
 */
function shouldAutoAssignGridArea(parentElement: any, config: any): boolean {
  if (!parentElement || !config) return false;
  
  // Helper to normalize string or array to array
  const toArray = (value: any): string[] => {
    if (!value) return [];
    if (Array.isArray(value)) return value;
    if (typeof value === 'string') return value.split(' ').filter(Boolean);
    return [];
  };
  
  // Get all presets from parent
  const parentLayouts = toArray(parentElement.layouts);
  const parentPresets = toArray(parentElement.presets);
  const allParentPresets = [...parentLayouts, ...parentPresets];
  
  // Check if any of the parent's presets have _auto-grid-areas enabled
  for (const presetName of allParentPresets) {
    // Look for preset in all categories
    const preset = findPreset(config.presets, presetName);
    if (preset && preset['_auto-grid-areas'] === true) {
      return true;
    }
  }
  
  return false;
}

/**
 * Recursively find a preset by name in the preset structure
 */
function findPreset(presets: any, name: string): any {
  if (!presets) return null;
  
  for (const key in presets) {
    const value = presets[key];
    
    // Check if this is the preset we're looking for
    if (key === name && typeof value === 'object' && !Array.isArray(value)) {
      // Check if it has CSS properties (not just subcategories)
      const hasStyles = Object.keys(value).some(k => 
        k.startsWith('--') || k.startsWith('_') || ['display', 'position', 'width', 'height'].includes(k)
      );
      if (hasStyles) {
        return value;
      }
    }
    
    // Recurse into subcategories
    if (typeof value === 'object' && !Array.isArray(value)) {
      const found = findPreset(value, name);
      if (found) return found;
    }
  }
  
  return null;
}
```

3. **Add `_auto-grid-areas: true` to grid presets** in ui-theme.json:
```json
"grid-bento-5": {
  // ... other properties
  "_auto-grid-areas": true
}
```

### Structure Approach (IN TRANSITION)
Testing nested structure without keys vs flat structure with IDs.

#### Current Implementation (Active):
- **Nested without keys**: Children as anonymous objects in arrays
- No CSS naming conflicts
- Example:
  ```json
  "children": [
    { "type": "one", "components": "button" },
    { "type": "one", "components": "switch" }
  ]
  ```

#### Previous Implementation (Available):
- **Flat with IDs**: All elements at root, referenced by keys
- To revert: Use string references in children arrays
- Example:
  ```json
  "children": ["child1", "child2"],
  "child1": { "type": "one" },
  "child2": { "type": "one" }
  ```

#### Testing Notes:
- Nested eliminates naming conflicts completely
- Flat structure better for visual editor drag/drop
- May need hybrid approach for production

## Implemented Features

### Auto-ID System (IMPLEMENTED)
Every element automatically receives a unique sequential ID.

#### How It Works
- All elements get IDs in the format: `one-1`, `one-2`, `one-3`... 
- Simple sequential numbering without padding
- Applied to every element regardless of type or parent
- IDs persist through the element lifecycle

### Child Hydration System (IMPLEMENTED)
CSS-based system for parents to automatically style their children based on position or other criteria.

#### Core Features
- **Position-based hydration**: Parents define styles for nth-child positions
- **Smart box container**: Box preset listens for parent CSS custom properties
- **Override capability**: Children can override with their own presets
- **Pure CSS solution**: No JavaScript required

#### Implementation
```json
"grid-cols-aligned": {
  "--display": "grid",
  "--grid-template-columns": "250px 1fr 250px",
  "_child-alignment": {
    "1": "start",
    "2": "center", 
    "3": "end"
  }
}
```

Box preset with hydration awareness:
```json
"box": {
  "--justify-items": "var(--parent-justify-items, stretch)",
  "--align-items": "var(--parent-align-items, stretch)"
}
```

### Grid Area Assignment System (IMPLEMENTED)
Universal automatic assignment of grid areas to all elements.

**Note**: We've reverted to universal assignment for simplicity during development. Parent-controlled assignment remains available as commented code. See "Features in Testing/Transition" section for details.

#### How It Works
- All elements with type 'one' automatically receive grid areas based on their index
- First child gets 'a', second gets 'b', third gets 'c', etc.
- Sequential grid areas: a, b, c...z, then aa, ab, ac...az, ba, bb... (infinite)
- Assigned as inline styles: `style="grid-area: a"`
- Manual override via `"grid-area": "e"` always takes precedence
- No configuration needed - works everywhere automatically

#### Architecture Benefits
- Simple and predictable behavior
- No need to configure parent grids
- Single source of truth for grid positioning
- Inline grid-area styles instead of CSS variable indirection
- Infinite scalability without defining infinite presets
- Every element is grid-ready by default

