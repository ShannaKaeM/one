# 01.03 - UI Generator

## Overview

The UI Generator is the React component generation engine that transforms JSON theme structures into live React interfaces. It provides a pure JSON-to-React conversion system that creates entire UIs without writing React code, working exclusively with the UI theme for application interfaces.

## Architecture

### Core Components

1. **UIGenerator Component**
   - Loads theme configurations via runtimeThemeProcessor
   - Recursively generates React elements from JSON
   - Handles special interactive elements (buttons, canvas areas)
   - Provides theme scoping wrapper

2. **Element Generation Pipeline**
   ```
   JSON Structure → Element Parser → Class Builder → React.createElement → DOM
   ```

3. **Class Building System**
   Builds CSS classes in specific order:
   - Theme name ('ui' or 'one')
   - Element type ('wrapper', 'text', 'image')
   - Presets (style combinations from theme)
   - Position (a, b, c, d for grid placement)

## Current Implementation

### Element Types
- **wrapper** → `<div>` (container elements)
- **text** → `<div>` or custom tag via 'as' property
- **image** → `<img>` with src, alt, loading attributes
- **[custom]** → Any HTML element type directly

### Special Handlers

#### Canvas Content Area
When `data-label="canvas-content"`:
```javascript
// Embeds DirectRenderer for ONE theme content
createElement(DirectRenderer, { theme: 'one' })
```

#### Interactive Elements Pattern
UIGenerator handles interactive elements through data-label attributes:

**+ONE Button:**
```javascript
if (element['data-label'] === 'add-one-button') {
  return createElement('button', {
    onClick: () => window.dispatchEvent(new CustomEvent('add-one-element'))
  });
}
```

**Grid/Snap Toggle Buttons:**
```javascript
if (element['data-label'] === 'toggle-grid-button') {
  return createElement('button', {
    onClick: () => window.dispatchEvent(new CustomEvent('toggle-grid'))
  });
}
```

This pattern enables:
- Theme-defined buttons with full styling
- Event-based communication
- Clean separation of concerns
- No hardcoded styles in React

### JSON Structure Example
```json
{
  "type": "wrapper",
  "preset": ["dashboard", "dark"],
  "position": "a",
  "children": [
    {
      "type": "text",
      "content": "Hello World",
      "preset": "heading"
    }
  ]
}
```

### Generated Output
```html
<div class="ui">
  <div class="ui wrapper dashboard dark a">
    <div class="ui text heading">Hello World</div>
  </div>
</div>
```

## Visual Builder Components

### Component Categories

1. **JSON-Driven Components** (Theme-Based)
   - UIGenerator - Generates UI from ui-theme.json
   - DirectRenderer - Renders ONE theme content

2. **Behavioral Components** (React-Based)
   These components are too complex for JSON due to deep form/function integration:
   - **GridOverlay** - Visual alignment grid with SVG patterns
   - **SelectionHandles** - 8-direction resize and drag handles
   - **VisualBuilderControls** - Grid/Snap toggle buttons

### Why Visual Builder Components Are Different

These components have complex behavioral requirements:
- Mouse interaction handling (drag, resize)
- Dynamic calculations (grid scales, snap points)
- Performance optimizations (SVG patterns)
- State management (selection, dragging states)

### Current Status

| Component | Functionality | Theme Integration |
|-----------|--------------|-------------------|
| GridOverlay | ✅ 20px/100px grid | ❌ Hardcoded colors |
| SelectionHandles | ✅ Drag/resize | ❌ Hardcoded #2196F3 |
| VisualBuilderControls | ✅ Toggle buttons | ❌ Inline styles |

## Key Connections

### With Theme Processor
```javascript
// UIGenerator loads themes via runtimeThemeProcessor
const themeConfig = runtimeThemeProcessor.getTheme(theme);

// Visual builder components will use:
const theme = runtimeThemeProcessor.getTheme('ui');
const colors = theme?.presets?.visualBuilder?.colors;
```

### With DirectRenderer
- UIGenerator embeds DirectRenderer for canvas content
- DirectRenderer handles ONE theme independently
- Visual builder tools overlay on DirectRenderer output

### Event System
- UIGenerator dispatches: `add-one-element`
- DirectRenderer listens for element events
- Cross-component communication via window events

## Design Principles

1. **Pure JSON Structure**
   - No React code in theme files
   - Complete UI from data
   - Visual editing compatibility

2. **Theme Scoping**
   - All elements wrapped in theme class
   - Enables `.ui .button` CSS patterns
   - No style conflicts between themes

3. **Behavioral Separation**
   - Complex interactions stay in React
   - Visual properties from theme
   - Clear boundary between data and behavior

## Current Implementation Status

### ✅ Completed
1. **Interactive Button Pattern**
   - Data-label based event system
   - Grid/Snap buttons integrated
   - VisualBuilderControls removed

2. **Event Communication**
   - Window events for loose coupling
   - DirectRenderer listens for UI events
   - Clean separation maintained

### ⚠️ Current Limitations

1. **No State Indication**
   - Buttons don't show active state
   - No hover effects yet

2. **Visual Builder Styling**
   - GridOverlay has hardcoded colors
   - SelectionHandles uses hardcoded #2196F3

## Next Steps

### Phase 1: Visual Builder Theme Integration
1. Create visual builder presets in ui-theme.json:
   ```json
   "visualBuilder": {
     "grid": {
       "--grid-minor-color": "hsl(0, 0%, 88%)",
       "--grid-major-color": "hsl(0, 0%, 80%)"
     },
     "selection": {
       "--handle-color": "hsl(207, 90%, 54%)",
       "--handle-size": "8px"
     }
   }
   ```

2. Update components to use theme colors

### Phase 2: Enhanced Interactivity
1. Generic event binding system
2. State-based class application
3. Dynamic component updates

### Phase 3: Advanced Features
1. Component property system
2. Conditional rendering
3. Dynamic data binding

## Development Guidelines

### DO:
- Keep UIGenerator focused on UI theme only
- Use DirectRenderer for ONE theme content
- Maintain pure JSON structure
- Use event system for communication

### DON'T:
- Mix UI and ONE theme responsibilities
- Add complex logic to JSON structure
- Hardcode styles in behavioral components
- Create React components in theme files

## Interactive Element Pattern

For adding interactivity to theme-defined elements:

### 1. Define in Theme JSON
```json
{
  "type": "text",
  "preset": "button",
  "content": "Action",
  "data-label": "unique-action-name"
}
```

### 2. Handle in UIGenerator
```javascript
if (element['data-label'] === 'unique-action-name') {
  return createElement('button', {
    className: classes.join(' '),
    onClick: () => {
      window.dispatchEvent(new CustomEvent('action-event'));
    }
  }, content);
}
```

### 3. Listen in Target Component
```javascript
useEffect(() => {
  function handleAction() {
    // Handle the action
  }
  window.addEventListener('action-event', handleAction);
  return () => {
    window.removeEventListener('action-event', handleAction);
  };
}, []);
```

This pattern maintains separation: theme defines appearance, UIGenerator adds behavior, components react to events.

## Performance Notes

- Single-pass element generation
- Efficient React.createElement usage
- Minimal re-renders
- Event delegation for interactivity

---

**Note**: UIGenerator is designed for UI theme only. DirectRenderer handles ONE theme separately. This separation ensures clean architecture and allows independent evolution of both systems.