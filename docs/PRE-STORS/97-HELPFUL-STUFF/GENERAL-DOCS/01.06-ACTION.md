# 01.06 - Action System

## Overview

The Action System provides a generic, extensible mechanism for defining element interactions in JSON. It enables any element to trigger actions without hardcoding behavior in components, following Studio1's philosophy of "define once, use everywhere."

## Architecture

### Core Components

1. **Action Definitions** (in theme JSON)
   - Type-based action categories
   - Target state mappings
   - Event specifications

2. **UIGenerator Handler**
   - Single generic handler for all actions
   - Interprets action definitions
   - Dispatches appropriate events

3. **Central State Management**
   - App-level state coordination
   - Action type processors
   - Event propagation

### Action Flow
```
User Click → UIGenerator → Action Lookup → Event Dispatch → State Update → UI Update
```

## Current Implementation

### Universal Action Pattern (Revolutionary Update)
```json
"actions": {
  "a": { "type": "toggle" },
  "b": { "type": "show" },
  "c": { "type": "hide" },
  "d": { "type": "custom" },
  "e": { "type": "updateProperty" },
  "f": { "type": "create" }
}
```

### Key Innovation: Target/Event in Elements
Instead of defining targets in actions, they're now defined where used:
```json
{
  "preset": "button Ghost",
  "content": "Grid",
  "data-action": "a",                    // Universal toggle action
  "data-target": "gridVisible",         // Target defined here!
  "data-active-when": "gridVisible"
}
```

This revolutionary change makes actions truly universal - like grid areas!

### Action Types

1. **toggle** - Switches boolean state
   ```json
   {
     "type": "toggle",
     "target": "stateProperty",
     "event": "optional-event-name"
   }
   ```

2. **custom** - Dispatches event only
   ```json
   {
     "type": "custom",
     "event": "event-name"
   }
   ```

3. **show** (planned) - Shows modal/panel
   ```json
   {
     "type": "show",
     "target": "modal-id"
   }
   ```

4. **navigate** (planned) - Route changes
   ```json
   {
     "type": "navigate",
     "target": "/path"
   }
   ```

## Usage Patterns

### Universal Toggle (Action "a")
```json
{
  "preset": "button Ghost",
  "content": "Grid",
  "data-action": "a",
  "data-target": "gridVisible",
  "data-active-when": "gridVisible"
}
```

### Custom Event (Action "d")
```json
{
  "preset": "button primary",
  "content": "+ ONE",
  "data-action": "d",
  "data-event": "add-one-element"
}
```

### Same Action, Different Targets
```json
// Grid toggle
{
  "data-action": "a",
  "data-target": "gridVisible"
}

// Snap toggle - SAME ACTION!
{
  "data-action": "a", 
  "data-target": "snapEnabled"
}

// Accordion toggle - STILL SAME ACTION!
{
  "data-action": "a",
  "data-target": "colorsAccordionOpen"
}
```

### Multi-Action Element
```json
{
  "preset": "card interactive",
  "data-action": "cards.select",
  "data-action-double-click": "cards.edit",
  "data-action-right-click": "cards.menu"
}
```

## Implementation Details

### UIGenerator Action Handler (Updated)
```javascript
const handleAction = (actionPath: string, element: any) => {
  const action = getActionFromPath(actionPath);
  
  if (!action) {
    console.warn(`Action not found: ${actionPath}`);
    return null;
  }
  
  // Dispatch event with target/event from ELEMENT, not action
  window.dispatchEvent(new CustomEvent('ui-action', {
    detail: {
      action: actionPath,
      type: action.type,
      target: element['data-target'] || action.target,  // Element first!
      event: element['data-event'] || action.event,     // Element first!
      property: action.property
    }
  }));
};
```

### App.tsx State Handler
```javascript
switch (type) {
  case 'toggle':
    setAppState(prev => ({
      ...prev,
      [target]: !prev[target]
    }));
    break;
    
  case 'custom':
    // Just dispatch the event
    break;
    
  case 'show':
    // Handle modal/panel display
    break;
}
```

## Benefits

### Original Benefits
1. **Extensibility** - Add new actions without code changes
2. **Consistency** - All interactions follow same pattern
3. **Declarative** - Behavior defined in JSON
4. **Testable** - Actions are data, not code
5. **Reusable** - Same actions across different elements

### Revolutionary Benefits (Universal Pattern)
1. **True Universality** - Action "a" can toggle ANY state
2. **Zero Semantic Lock-in** - No hardcoded meanings
3. **Infinite Flexibility** - Same action, different contexts
4. **Grid Area Philosophy** - Actions as positional slots
5. **Simplified Mental Model** - Just a/b/c/d/e/f to remember

### Comparison
```json
// Old Way - Semantic Lock-in
"actions": {
  "toggles": {
    "grid": { "target": "gridVisible" },
    "snap": { "target": "snapEnabled" },
    "darkMode": { "target": "darkModeEnabled" }
  }
}

// New Way - Universal Freedom
"actions": {
  "a": { "type": "toggle" }  // That's it!
}

// Usage defines behavior
{ "data-action": "a", "data-target": "gridVisible" }
{ "data-action": "a", "data-target": "snapEnabled" }
{ "data-action": "a", "data-target": "darkModeEnabled" }
```

## Future Enhancements

### Enhanced Action Types
```json
"actions": {
  "modals": {
    "settings": {
      "type": "modal",
      "component": "SettingsModal",
      "props": { "size": "large" }
    }
  },
  "navigation": {
    "home": {
      "type": "navigate",
      "target": "/",
      "transition": "slide"
    }
  },
  "data": {
    "save": {
      "type": "api",
      "endpoint": "/api/save",
      "method": "POST"
    }
  }
}
```

### Action Composition
```json
{
  "data-action": "composed.saveAndClose",
  "composed": {
    "saveAndClose": [
      "data.save",
      "modals.close",
      "navigation.home"
    ]
  }
}
```

### Conditional Actions
```json
{
  "data-action": "conditional.save",
  "conditional": {
    "save": {
      "if": "formValid",
      "then": "data.save",
      "else": "validation.show"
    }
  }
}
```

## Integration with State Presets

Actions and State Presets work together:
- Actions change state
- State Presets provide visual feedback
- Together create rich interactions

Example:
```json
{
  "preset": "button Ghost",
  "data-action": "toggles.feature",
  "data-active-when": "featureEnabled",
  "states": {
    "active": "button primary",
    "hover": "button Ghost-hover",
    "active-hover": "button primary-hover"
  }
}
```

## Best Practices

1. **Namespace Actions** - Use categories (toggles, modals, navigation)
2. **Descriptive Names** - `toggles.grid` not `tg`
3. **Event Naming** - Past tense for events: `grid-toggled`
4. **State Alignment** - Action targets match state properties
5. **Documentation** - Document custom action types

## Examples

### Feature Toggle Set
```json
"actions": {
  "features": {
    "darkMode": {
      "type": "toggle",
      "target": "darkModeEnabled",
      "event": "theme-changed"
    },
    "animations": {
      "type": "toggle",
      "target": "animationsEnabled"
    },
    "sounds": {
      "type": "toggle",
      "target": "soundsEnabled"
    }
  }
}
```

### Modal System
```json
"actions": {
  "modals": {
    "showSettings": {
      "type": "show",
      "target": "settingsModal"
    },
    "showHelp": {
      "type": "show",
      "target": "helpModal"
    },
    "closeAll": {
      "type": "custom",
      "event": "close-all-modals"
    }
  }
}
```

### Tool Selection
```json
"actions": {
  "tools": {
    "select": {
      "type": "set",
      "target": "currentTool",
      "value": "select"
    },
    "draw": {
      "type": "set",
      "target": "currentTool",
      "value": "draw"
    }
  }
}
```

---

**Note**: The Action System enables Studio1 to define complex interactions in JSON, maintaining the framework's core principle of configuration over code while providing unlimited extensibility.