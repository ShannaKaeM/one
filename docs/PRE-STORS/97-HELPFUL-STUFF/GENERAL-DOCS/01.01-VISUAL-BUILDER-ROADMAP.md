# TRANSFORMER COMPONENT ROADMAP üöÄ

## **üìù DOCUMENTATION RULES - READ FIRST**

**When completing ANY section:**
- **‚úÖ ROADMAP** = Current state facts only (architecture, connections, how it works)
- **‚ùå NO** temporal language ("new", "added", "updated", "replaced", "now")  
- **‚ùå NO** change history ("fixed", "changed from X to Y", "previously")
- **‚úÖ Write as final documentation** - like it always existed this way

**For implementation details:**
- **üìã SESSION LOGS** = All changes, decisions, fixes, and history
- **üìÅ LOG FOLDER:** [`/docs/STUDIO1/SESSIOIN-LOGS/`](/docs/STUDIO1/SESSIOIN-LOGS/)
- **üìñ READ:** [Session Log README](/docs/STUDIO1/SESSIOIN-LOGS/README.md) for format

---

## üéØ VISION SUMMARY
Build a revolutionary component system where ONE element can transform into anything (button ‚Üí card ‚Üí hero) through presets, with flexible content slots, JSON hydration, and a unified visual canvas.

## üìã QUICK REFERENCE FOR NEXT AGENT

### Core Concepts:
1. **Flat Elements** - Single elements with internal layers (Studio1)
2. **Flat Canvas** - Multiple elements arranged visually (S4) 
3. **Transformer Components** - Elements that change completely via presets
4. **Content Slots** - Toggleable content areas with JSON hydration
5. **Edit Mode** - Temporary ungroup ‚Üí edit ‚Üí regroup workflow
6. **Layer Tree** - Photoshop-like layers panel (replaces library sidebar)

### Key Innovation:
- One component + different presets = completely different outputs
- No more component variants, just transformations!

---

## üõ†Ô∏è PHASE 1: FOUNDATION (Week 1-2)

### 1.1 Enhanced Canvas System ‚úÖ
**File:** `/src/components/DirectRenderer.tsx`

The canvas system supports direct element creation with three primitive types configured in `/public/data/themes/one-theme.json`:

```javascript
// Element creation with theme defaults
const elementTypes = {
  wrapper: { /* 200x200px gray container */ },
  text: { /* Centered text with background */ },
  image: { /* Image with default source */ }
}

// Multi-selection state management
const [selectedElementIds, setSelectedElementIds] = useState<string[]>([])
// Visual feedback: purple outline for multi-selection, blue for single
```

**Current Implementation:**
- Canvas header contains "+ Wrapper", "+ Text", "+ Image" buttons
- Shift+Click enables multi-selection with visual feedback
- Drag-to-select rectangle with purple dashed border (5px movement threshold)
- Elements use absolute positioning with staggered placement
- Selection handles work consistently across all element types
- Escape key deselects all elements and cancels drag operations
- Element naming system: "Wrapper 1", "Text 2", "Image 3" based on type counters

**Event Listeners:**
```javascript
// Element creation events
window.addEventListener('add-wrapper-element', handleAddElement)
window.addEventListener('add-text-element', handleAddElement)
window.addEventListener('add-image-element', handleAddElement)

// Selection and interaction
document.addEventListener('keydown', handleKeyDown)  // Escape to deselect
canvasRef.current.addEventListener('mousedown', handleMouseDown)
document.addEventListener('mousemove', handleMouseMove)
document.addEventListener('mouseup', handleMouseUp)
```

### 1.2 Layer Tree Sidebar ‚úÖ
**File:** `/src/components/LayerTree.tsx`

The Layer Tree provides a hierarchical view of all canvas elements with professional editing capabilities:

```javascript
interface LayerTreeProps {
  elements: any[];
  selectedIds: string[];
  onSelect: (ids: string[]) => void;
  onReorder?: (dragId: string, dropId: string) => void;
  onVisibilityToggle?: (elementId: string, visible: boolean) => void;
  onLockToggle?: (elementId: string, locked: boolean) => void;
  onRename?: (elementId: string, newName: string) => void;
}
```

**Implementation:**
- Hierarchical element display with recursive tree building for nested groups
- Double-click to rename elements with inline editing
- Visibility toggle (üëÅÔ∏è) controls element rendering on canvas
- Lock toggle (üîí) prevents selection and editing
- Drag & drop reordering updates z-index positions
- Expand/collapse groups with arrow indicators
- Multi-selection support synced with canvas (Shift+click)
- Visual feedback: blue for selected, purple for multi-selected
- Element type icons: ‚ñ° wrapper, T text, ‚ñ≠ image, ‚ñ£ group

**Event System:**
- `element-visibility-changed` - Toggle element visibility
- `element-lock-changed` - Lock/unlock elements
- `elements-reordered` - Drag & drop reordering
- `element-renamed` - Update element names

**State Management:**
- Local state for expanded groups, hidden/locked elements
- Canvas elements passed from App.tsx via `canvas-elements-updated` event
- Bidirectional selection sync with DirectRenderer

---

## üîß PHASE 2: GROUPING SYSTEM ‚úÖ

### 2.1 Multi-Selection ‚úÖ
**File:** `/src/components/DirectRenderer.tsx`

**Implementation:**
- Shift+Click enables multi-selection with purple outline
- Drag-to-select rectangle with purple dashed border
- Selection state tracked in `selectedElementIds` array
- Visual feedback: blue for single selection, purple for multi-selection
- Escape key deselects all elements

### 2.2 Group/Ungroup Functionality ‚úÖ
**File:** `/src/components/DirectRenderer.tsx`

Groups are special elements that contain other elements as children:

```javascript
// Group structure
const group = {
  id: `group-${timestamp}`,
  type: 'group',
  isGroup: true,
  children: ['element-1', 'element-2'],
  style: {
    position: 'absolute',
    left: `${minX}px`,
    top: `${minY}px`,
    width: `${boundingWidth}px`,
    height: `${boundingHeight}px`,
    border: '1px dashed rgba(0,0,0,0.2)'
  }
}

// Child elements have parentGroup property
element.parentGroup = 'group-123'
```

**Grouping Implementation:**
- Group button appears dynamically when 2+ elements selected (`multiSelectionCount > 1`)
- Groups calculate bounding box from child positions
- Children maintain relative positions within group
- Clicking grouped elements selects the parent group
- Groups move as single units with all children
- Elements automatically named: "Wrapper 1", "Text 2", "Group 3", etc.

**Ungrouping Implementation:**
- Ungroup button appears when group selected (`selectedGroupId` in UI state)
- Restores child elements to absolute canvas positions:
  ```javascript
  // Calculate absolute position from group + relative
  const absoluteLeft = groupLeft + relativeLeft;
  const absoluteTop = groupTop + relativeTop;
  ```
- Removes `parentGroup` reference from children
- Deletes the group element
- Clears selection state

**Event Flow:**
1. UI button click ‚Üí `ui-action` event
2. App.tsx ‚Üí `group-elements` or `ungroup-elements` CustomEvent
3. DirectRenderer ‚Üí handleGroupElements or handleUngroupElements
4. State cleanup ‚Üí selection updated

### 2.3 Convert to Flat Element (Future)
**File:** `/src/utils/transformers.ts` (NEW)

```javascript
// Convert group to Flat Element
const convertToFlatElement = (group: Group): FlatElement => {
  return {
    id: group.id,
    type: 'one',
    preset: 'custom',
    content: {
      layers: group.children.map(child => ({
        type: child.type,
        value: child.content,
        style: child.style
      }))
    }
  }
}
```

**Tasks:**
- [ ] Implement group ‚Üí Flat Element conversion
- [ ] Preserve all styling and content
- [ ] Add "Convert to Component" button
- [ ] Create reverse operation (Flat Element ‚Üí Group)

---

## üìù PHASE 3: CONTENT SLOTS SYSTEM (Week 3-4)

### 3.1 Slot Definition Structure
**File:** `/src/types/slots.ts` (NEW)

```typescript
interface ContentSlot {
  type: 'text' | 'image' | 'icon'
  default: string
  visible: boolean
  required?: boolean
  style?: CSSProperties
  variants?: Record<string, string>
}

interface SlotConfig {
  [slotName: string]: ContentSlot
}
```

### 3.2 Edit Mode Implementation
**File:** `/src/components/EditMode.tsx` (NEW)

```javascript
// Toggle edit mode
const [editingId, setEditingId] = useState<string | null>(null)

const enterEditMode = (elementId: string) => {
  // Temporarily convert to group
  const tempGroup = flatElementToGroup(element)
  setEditingId(elementId)
}

const exitEditMode = (save: boolean) => {
  if (save) {
    // Convert back to Flat Element with updates
  }
  setEditingId(null)
}
```

**Tasks:**
- [ ] Create edit mode UI toggle
- [ ] Implement temporary ungrouping
- [ ] Add inline editing for text
- [ ] Add image replacement UI
- [ ] Implement save/cancel actions

### 3.3 Slot Toggle UI
**File:** `/src/components/SlotManager.tsx` (NEW)

```javascript
// In property panel
<SlotManager
  slots={element.content.slots}
  onToggle={(slotName, visible) => {
    updateSlotVisibility(element.id, slotName, visible)
  }}
/>
```

**Tasks:**
- [ ] Create slot visibility toggles
- [ ] Update element when slots change
- [ ] Show/hide content based on slot state
- [ ] Implement required slot validation

---

## üíß PHASE 4: JSON HYDRATION (Week 4-5)

### 4.1 Hydration Engine
**File:** `/src/utils/hydration.ts` (NEW)

```typescript
const hydrate = (
  template: ComponentTemplate,
  props: Record<string, any>
): HydratedComponent => {
  // Replace {{ placeholders }} with values
  // Handle conditionals
  // Process computed properties
}
```

**Tasks:**
- [ ] Implement placeholder replacement
- [ ] Add conditional rendering support
- [ ] Handle nested props
- [ ] Implement default values
- [ ] Add collection mapping for lists

### 4.2 Content Management
**File:** `/src/content/index.ts` (NEW)

```javascript
// Content store
const contentStore = {
  heroes: {
    'home-hero': { title: 'Welcome', ... },
    'about-hero': { title: 'About Us', ... }
  },
  cards: { ... }
}

// Content loader
const loadContent = async (type: string, id: string) => {
  // Fetch from store/API/CMS
}
```

**Tasks:**
- [ ] Create content storage structure
- [ ] Implement content loader
- [ ] Add content picker UI
- [ ] Create content preview system

---

## üé® PHASE 5: PRESET ENHANCEMENT (Week 5-6)

### 5.1 Smart Presets
**File:** `/src/presets/smart-presets.ts` (NEW)

```javascript
// Presets that adapt to active slots
const heroPresets = {
  'hero-minimal': (slots) => ({
    // Layout changes based on which slots are active
    display: slots.description.visible ? 'grid' : 'flex',
    gridTemplate: slots.description.visible 
      ? '"title" "description"' 
      : '"title"'
  })
}
```

**Tasks:**
- [ ] Create slot-aware presets
- [ ] Implement preset preview
- [ ] Add preset categories
- [ ] Build preset switcher UI

### 5.2 Component Library
**File:** `/src/library/transformer-components.ts` (NEW)

```javascript
export const transformerLibrary = {
  heroes: [
    {
      id: 'hero-transformer',
      name: 'Hero Component',
      slots: { ... },
      presets: ['hero-left', 'hero-center', 'hero-minimal']
    }
  ]
}
```

**Tasks:**
- [ ] Create base component templates
- [ ] Define standard slot configurations
- [ ] Build component picker UI
- [ ] Add component preview

---

## üöÄ PHASE 6: INTEGRATION & POLISH (Week 6-7)

### 6.1 Export System
- [ ] Export as Flat HTML (S4 style)
- [ ] Export as React/Vue components
- [ ] Export as static HTML
- [ ] Include hydrated content

### 6.2 Performance Optimization
- [ ] Implement virtual scrolling for layer tree
- [ ] Add element caching
- [ ] Optimize re-renders
- [ ] Add undo/redo system

### 6.3 Developer Experience
- [ ] Add keyboard shortcuts
- [ ] Implement copy/paste
- [ ] Add element templates
- [ ] Create onboarding flow

---

## üìä SUCCESS METRICS

1. **Simplicity Test**: Can a user create a hero in < 1 minute?
2. **Transformation Test**: Can one component become 5+ different layouts?
3. **Performance Test**: Handle 100+ elements smoothly
4. **Export Test**: Clean, production-ready output

---

## üéØ POC GOALS (Week 1)

Build minimal version proving core concept:

1. **Canvas with 3 element types** (wrapper, text, image) ‚úÖ
2. **Basic grouping** (select multiple ‚Üí group) ‚úÖ
3. **Convert to Flat Element** (group ‚Üí component)
4. **Apply 3 presets** (changes layout completely)
5. **Basic edit mode** (ungroup ‚Üí edit ‚Üí regroup)

---

## üìö KEY DOCUMENTS TO REVIEW

1. `/docs/STUDIO1/01.01.02-FLAT-ELEMENT-HTML.md` - Flat Element concept
2. `/docs/OTHER/A-S4-DOCS/01-CORE-INNOVATIONS/1.03-FLAT-HTML.md` - Flat Canvas system
3. `/docs/STUDIO1/WHITEBOARDS/WB-01-*.md` - All whiteboard discussions
4. `/docs/STUDIO1/01.01-VSB-Shanna.md` - Progress tracking checklist
5. `/docs/STUDIO1/SESSIOIN-LOGS/SESSION-015-LAYER-TREE.md` - Layer Tree implementation

## üèóÔ∏è TECHNICAL ARCHITECTURE

### Element System
- **Base Elements**: wrapper, text, image (configured in one-theme.json)
- **Groups**: Special elements with `isGroup: true` and `children[]` array
- **Selection**: Single (blue) and multi-selection (purple) with state tracking
- **Positioning**: All elements use absolute positioning on canvas
- **Naming**: Automatic naming based on type counters (Wrapper 1, Text 2, etc.)

### Event System
- `element-selected`: Single element selection
- `elements-selected`: Multi-element selection
- `group-elements`: Create group from selection
- `ungroup-elements`: Break group apart
- `element-moved`: Update element position
- `element-resized`: Update element dimensions
- `element-visibility-changed`: Toggle visibility
- `element-lock-changed`: Lock/unlock elements
- `elements-reordered`: Drag & drop reordering
- `element-renamed`: Update element names
- `canvas-elements-updated`: Sync canvas with Layer Tree

### State Management
- Selection state managed in App.tsx
- Canvas elements managed in DirectRenderer.tsx
- UI state includes `multiSelectionCount` and `selectedGroupId` for conditional rendering
- Layer Tree maintains local state for UI features (expanded, hidden, locked)

---

## üî• QUICK WIN SUGGESTIONS

1. Start with grouping - it's the foundation ‚úÖ
2. Layer tree can be basic initially (just hierarchy) ‚úÖ
3. Focus on button ‚Üí card ‚Üí hero transformation as POC
4. JSON hydration can start with simple find/replace

---

**Remember**: The goal is to prove that ONE component can transform into ANYTHING through presets while maintaining editable content through slots. This is the future of web components!

Good luck! You're building something revolutionary! üöÄ
